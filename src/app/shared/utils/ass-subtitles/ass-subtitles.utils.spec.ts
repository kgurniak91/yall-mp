import {AssSubtitlesUtils} from "../../../../../shared/utils/ass-subtitles.utils";

const ASS_SUBTITLES = `
[Script Info]
; Script generated by Aegisub r7725
Title: Default Aegisub file
ScriptType: v4.00+
PlayResX: 1920
PlayResY: 1080

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Source Sans Pro Semibold,84,&H00FFFFFF,&H000000FF,&H001D1D37,&HC00E0E2E,-1,0,0,0,97,100,0,0,1,5.1,2.7,2,180,180,63,1
Style: Sign-Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,0,0,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Comment: 0,0:00:33.97,0:00:40.47,mmr3title,,0,0,0,,A comment line to be ignored.
Dialogue: 10,0:00:03.41,0:00:04.51,Default,,0,0,0,,Sniff. Sniff. Sniff.
Dialogue: 10,0:00:04.51,0:00:05.33,Default,,0,0,0,,Sniff. Sniff.
Dialogue: 10,0:00:16.39,0:00:19.08,Default,,0,0,0,,Still good, but it'll go bad soon. Close one!
Dialogue: 0,0:00:25.58,0:00:29.96,Sign-Default,,0,0,0,,{\\pos(974,758)}Not Edible
Dialogue: 1,0:00:25.58,0:00:29.96,Sign-Default,,0,0,0,,{\\blur0.5}Not Edible
Dialogue: 10,0:00:26.77,0:00:29.34,Default,,0,0,0,,Strike!
`;

describe('AssSubtitlesUtils', () => {
  describe('formatTime', () => {
    it('should format zero correctly', () => {
      expect(AssSubtitlesUtils.formatTime(0)).toBe('0:00:00.00');
    });

    it('should format time under a minute with milliseconds', () => {
      expect(AssSubtitlesUtils.formatTime(16.39)).toBe('0:00:16.39');
    });

    it('should format time over a minute', () => {
      expect(AssSubtitlesUtils.formatTime(86.52)).toBe('0:01:26.52');
    });

    it('should correctly pad single-digit minutes and seconds', () => {
      expect(AssSubtitlesUtils.formatTime(62.05)).toBe('0:01:02.05');
    });

    it('should format time over an hour', () => {
      expect(AssSubtitlesUtils.formatTime(3679.12)).toBe('1:01:19.12');
    });

    it('should correctly round centiseconds', () => {
      expect(AssSubtitlesUtils.formatTime(12.345)).toBe('0:00:12.35');
      expect(AssSubtitlesUtils.formatTime(12.344)).toBe('0:00:12.34');
    });
  });

  describe('parseEvents', () => {
    it('should parse a valid ASS file correctly', () => {
      const result = AssSubtitlesUtils.parseEvents(ASS_SUBTITLES);
      if (!result) {
        fail('parseEvents should have returned ParsedAssEvents but was null.');
        return;
      }

      expect(result.header).toContain('[Script Info]');
      expect(result.header).not.toContain('[Events]');
      expect(result.formatLine).toBe('Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text');
      expect(result.dialogueLines.length).toBe(6); // Should ignore the 'Comment:' line
      expect(result.dialogueLines[0]).toContain('Sniff. Sniff. Sniff.');

      expect(result.formatSpec.size).toBe(10);
      expect(result.formatSpec.get('Layer')).toBe(0);
      expect(result.formatSpec.get('Start')).toBe(1);
      expect(result.formatSpec.get('End')).toBe(2);
      expect(result.formatSpec.get('Text')).toBe(9);
    });

    it('should be case-insensitive for [Events] and format:', () => {
      const mixedCaseContent = ASS_SUBTITLES.replace('[Events]', '[EvEnTs]').replace('Format:', 'fOrMaT:');
      const result = AssSubtitlesUtils.parseEvents(mixedCaseContent);
      expect(result).not.toBeNull();
      expect(result?.dialogueLines.length).toBe(6);
    });

    it('should return null if [Events] section is missing', () => {
      const content = `[Script Info]\nTitle: Test\n[V4+ Styles]\nStyle: Default,Arial,20`;
      expect(AssSubtitlesUtils.parseEvents(content)).toBeNull();
    });

    it('should return null if Format line is missing', () => {
      const content = `[Script Info]\nTitle: Test\n[Events]\nDialogue: 0,0:00:00.00,0:00:01.00...`;
      expect(AssSubtitlesUtils.parseEvents(content)).toBeNull();
    });
  });

  describe('scopeAssContent', () => {
    it('should filter to a single, specific dialogue line', () => {
      const result = AssSubtitlesUtils.scopeAssContent(ASS_SUBTITLES, 16.0, 19.5);
      if (!result) {
        fail('scopeAssContent should have returned a string but was undefined.');
        return;
      }

      const expectedDialogue = 'Dialogue: 10,0:00:16.39,0:00:19.08,Default,,0,0,0,,Still good, but it\'ll go bad soon. Close one!';
      expect(result).toContain('[Script Info]');
      expect(result).toContain(expectedDialogue);
      expect(result).not.toContain('Sniff. Sniff.');
      expect(result.split('Dialogue:').length - 1).toBe(1);
    });

    it('should include lines that partially overlap the start time', () => {
      const result = AssSubtitlesUtils.scopeAssContent(ASS_SUBTITLES, 17.0, 20.0);
      if (!result) {
        fail('scopeAssContent should have returned a string but was undefined.');
        return;
      }

      expect(result).toContain('Still good, but it\'ll go bad soon. Close one!');
      expect(result.split('Dialogue:').length - 1).toBe(1);
    });

    it('should include lines that partially overlap the end time', () => {
      const result = AssSubtitlesUtils.scopeAssContent(ASS_SUBTITLES, 15.0, 17.0);
      if (!result) {
        fail('scopeAssContent should have returned a string but was undefined.');
        return;
      }

      expect(result).toContain('Still good, but it\'ll go bad soon. Close one!');
      expect(result.split('Dialogue:').length - 1).toBe(1);
    });

    it('should include lines that are fully contained within the time range', () => {
      const result = AssSubtitlesUtils.scopeAssContent(ASS_SUBTITLES, 3.0, 6.0);
      if (!result) {
        fail('scopeAssContent should have returned a string but was undefined.');
        return;
      }

      expect(result).toContain('Sniff. Sniff. Sniff.');
      expect(result).toContain('Sniff. Sniff.');
      expect(result.split('Dialogue:').length - 1).toBe(2);
    });

    it('should handle complex, overlapping, and concurrent lines correctly', () => {
      const result = AssSubtitlesUtils.scopeAssContent(ASS_SUBTITLES, 25.0, 30.0);
      if (!result) {
        fail('scopeAssContent should have returned a string but was undefined.');
        return;
      }

      expect(result).toContain('{\\pos(974,758)}Not Edible');
      expect(result).toContain('{\\blur0.5}Not Edible');
      expect(result).toContain('Strike!');
      expect(result.split('Dialogue:').length - 1).toBe(3);
    });

    it('should return no dialogue lines for a time range with no subtitles (a gap)', () => {
      const result = AssSubtitlesUtils.scopeAssContent(ASS_SUBTITLES, 10.0, 15.0);
      if (!result) {
        fail('scopeAssContent should have returned a string but was undefined.');
        return;
      }

      expect(result).toContain('[Events]');
      expect(result).toContain('Format:');
      expect(result.split('Dialogue:').length - 1).toBe(0);
    });

    it('should return undefined for malformed content', () => {
      spyOn(console, 'error').and.callFake(() => {});
      const noEventsContent = `[Script Info]\nTitle: Test`;
      const noFormatContent = `[Script Info]\nTitle: Test\n[Events]`;
      const badFormatContent = ASS_SUBTITLES.replace('Start, End', 'Beginning, Finish');

      expect(AssSubtitlesUtils.scopeAssContent(noEventsContent, 0, 10)).toBeUndefined();
      expect(AssSubtitlesUtils.scopeAssContent(noFormatContent, 0, 10)).toBeUndefined();
      expect(AssSubtitlesUtils.scopeAssContent(badFormatContent, 0, 10)).toBeUndefined();
    });
  });
});
